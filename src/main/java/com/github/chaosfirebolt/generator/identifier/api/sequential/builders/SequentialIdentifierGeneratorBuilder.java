/*
 * Copyright 2021-2023 Boyan Georgiev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.chaosfirebolt.generator.identifier.api.sequential.builders;

import com.github.chaosfirebolt.generator.identifier.api.sequential.SequentialIdentifierGenerator;
import com.github.chaosfirebolt.generator.identifier.api.sequential.sequence.Sequence;
import com.github.chaosfirebolt.generator.identifier.api.sequential.sequence.SequenceDecoration;
import com.github.chaosfirebolt.generator.identifier.internal.builders.SequentialIdentifierGeneratorFactory;
import org.apiguardian.api.API;

import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * Builder for {@link SequentialIdentifierGenerator}s. <strong>Do not</strong> use {@link #fluidTypeBuilder} and {@link #constantTypeBuilder} to create new builders.
 * Use {@link SequentialIdentifierGenerator#fluidTypeBuilder()} and {@link SequentialIdentifierGenerator#constantTypeBuilder()} instead.
 *
 * @param <E>  type of the elements produced by the sequence
 * @param <ID> type of the identifiers produced by generator
 */
@API(status = API.Status.STABLE, since = "2.1.0")
public abstract sealed class SequentialIdentifierGeneratorBuilder<E, ID> permits FluidTypeSequentialBuilder, ConstantTypeSequentialBuilder {

  private static final Supplier<? extends RuntimeException> DEFAULT_EXCEPTION_FACTORY = () -> new NoSuchElementException("Can't generate more identifiers");

  private final SequentialIdentifierGeneratorFactory<E, ID> generatorFactory;
  private Sequence<E> sequence;
  /**
   * Function to transform element generated by a sequence to the required identifier type.
   */
  protected Function<E, ID> mapper;
  private SequenceDecoration<ID> decoration;
  private Supplier<? extends RuntimeException> exceptionFactory;

  SequentialIdentifierGeneratorBuilder(SequentialIdentifierGeneratorFactory<E, ID> generatorFactory) {
    this.generatorFactory = generatorFactory;
  }

  /**
   * Do not use, internal!
   *
   * @param generatorFactory factory to create the generator
   * @param <E>              type of the elements produced by the sequence
   * @param <ID>             type of the identifiers produced by generator
   * @return new fluid type builder
   */
  @API(status = API.Status.INTERNAL, since = "2.1.0")
  public static <E, ID> SequentialIdentifierGeneratorBuilder<E, ID> fluidTypeBuilder(SequentialIdentifierGeneratorFactory<E, ID> generatorFactory) {
    return new FluidTypeSequentialBuilder<>(generatorFactory);
  }

  /**
   * Do not use, internal!
   *
   * @param generatorFactory factory to create the generator
   * @param <ID>             type of the elements and identifiers
   * @return new constant type builder
   */
  @API(status = API.Status.INTERNAL, since = "2.1.0")
  public static <ID> SequentialIdentifierGeneratorBuilder<ID, ID> constantTypeBuilder(SequentialIdentifierGeneratorFactory<ID, ID> generatorFactory) {
    return new ConstantTypeSequentialBuilder<>(generatorFactory);
  }

  /**
   * Sets the sequence to be used by the identifier generator.
   * This is mandatory attribute.
   *
   * @param sequence the sequence
   * @return this builder
   */
  public SequentialIdentifierGeneratorBuilder<E, ID> setSequence(Sequence<E> sequence) {
    this.sequence = sequence;
    return this;
  }

  /**
   * Sets mapper function to transform element generated by {@link Sequence} to the required identifier type.
   * Some builders consider this attribute mandatory and throw exception, is missing, while others may provide default mapper.
   *
   * @param mapper the mapper
   * @return this builder
   */
  public SequentialIdentifierGeneratorBuilder<E, ID> setMapper(Function<E, ID> mapper) {
    this.mapper = mapper;
    return this;
  }

  /**
   * Sets a decoration, to be applied on the transformed result after the mapping operation.
   * Defaults to {@link SequenceDecoration#noOp}, if a custom decoration is not set.
   *
   * @param decoration decoration to be applied
   * @return this builder
   */
  public SequentialIdentifierGeneratorBuilder<E, ID> setDecoration(SequenceDecoration<ID> decoration) {
    this.decoration = decoration;
    return this;
  }

  /**
   * Sets the exception factory to create the required exception, when the sequence is unable to generate more elements.
   * Optional attribute, if missing the builder will supply default one.
   *
   * @param exceptionFactory the factory
   * @return this builder
   */
  public SequentialIdentifierGeneratorBuilder<E, ID> setExceptionFactory(Supplier<? extends RuntimeException> exceptionFactory) {
    this.exceptionFactory = exceptionFactory;
    return this;
  }

  abstract Function<E, ID> getMapper();

  /**
   * Creates a new {@link SequentialIdentifierGenerator} from this builder.
   *
   * @return new instance of sequential identifier generator
   * @throws NullPointerException if sequence is null, or if mapper is null, and this builder does not support providing default mapper
   */
  public SequentialIdentifierGenerator<E, ID> build() {
    Sequence<E> sequence = Objects.requireNonNull(this.sequence, "Missing sequence");
    Supplier<? extends RuntimeException> exceptionFactory = this.exceptionFactory != null ? this.exceptionFactory : DEFAULT_EXCEPTION_FACTORY;
    SequenceDecoration<ID> decoration = this.decoration != null ? this.decoration : SequenceDecoration.noOp();
    return this.generatorFactory.create(sequence, this.getMapper(), decoration, exceptionFactory);
  }
}
